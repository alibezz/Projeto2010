Simple Coreference Resolution with Rich Syntactic and Semantic Features

Unsupervised system. Na verdade, pega o parser sintático dum treebank. A maior parte dos erros se deve  a parsing mistakes ou missing knowledge; não ao modelo n conseguir fechar a coreferencia.

3 tipos de menção: proper (Dilma), nominal (candidata), pronominal (ela).

Monta o par: para cada menção mi, selecione a single-best antecedent amongst m1, mi-1 ou NULL, se a underlying entity ainda n foi evocada. A escolha da menção ou NULL é assim:

                                                 mentions. This system yields a rather low 48.9
• Syntactic Constraint: Based on syntac-
                                                 pairwise F1 (see BASE-FLAT in Table 2). There
  tic configurations, either force or disallow
                                                 are many, primarily recall, errors made choos-
  coreference between the mention and an an-
                                                 ing antecedents for all mention types which we
  tecedent. Propagate this constraint (see Fig-
                                                 will address by adding syntactic and semantic con-
  ure 4).
                                                 straints.
• Semantic/Syntactic Filter: Filter the re-
                                                 3.1   Adding Syntactic Information
  maining possible antecedents based upon
                                                 In this section, we enrich the syntactic represen-
  compatibility with the mention (see Fig-
                                                 tation and information in our system to improve
  ure 2).
                                                 results.
• Selection: Select the ‘closest’ mention from
  the set of remaining possible antecedents (see
  Figure 1) or the NULL antecedent if empty.


Parseia cm stanford parser e, pra cada mention, a situa em uma parse tree e utiliza o tamanho do shortest path entre duas mentions como distância.


Coreferent mentions must agree in number, person, gender and entity type. O artigo implementa person, number e entity type agreement.

Associar menções não-pronominais é mais complicado. Como saber se são compatíveis?

Coisas sintáticas que ajudam a resolver nn-pronominal: Role appositives => Vc tem uma pessoa filha dum nP? o filho esquero é apositivo, tipo:painter (apositivo) pablo picasso (pessoa). daí, só busca coreferencia até o pai (a lista de antecedentes). Além disso, qqqr non-appositive nP n pode ser coreferent com seu pai. Aí busca a menor distancia.

Agora, a semantica! Eles extraem padrões semânticos assim: surgem head pairs; daí, extrai counts em tree fragments que estejam entre os nodos que ocorrem entre os head pairs. Limita os paths extraidos a sentenças adjacentes e n podem ter tamanho maior que 10. aih filtra esse conjunto de paths para aqueles que ocorrem mais de 100 vezes com pelo menos 10 distinct seed head word pairs. Cria-se um cconjunto de compatiblee word pairs e, aí, eles sãao usados pra relax the semantic compatibility filter: mentions are compatible with prior mentions with the same head ****or**** with a semantically compatible head word.

Erros encontrados:

Sem. compat.: missing information about the compatibility of two words, like pay and wage.

Syn. compat.: ex.: dissallowing they to refer team

Head: errors involving the assumption that mentions with the same head are always compatible => lebanon and southern lebanon.

Internal NP: Falta NP structure pra marcar role appositives (an NP modifies the head NP, describing the role of that entity).

Prag./Disc.: Errors where discourse salience (aquela coisa de *O Nintendo da América*) é necessária pra desambiguar menções antecedentes.

Process error: Tokenization, parse ou NER errors.
